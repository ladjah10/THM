import { useState, useEffect, useMemo } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { RefreshCw, FileDown, Search, Loader2, Mail, Info, Download, AlertCircle } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip as RechartsTooltip, ResponsiveContainer, PieChart, Pie, Cell } from "recharts";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Table, TableBody, TableCaption, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import type { AssessmentScores, UserProfile, DemographicData, AssessmentResult, SectionScore } from "@/types/assessment";
import type { AnalyticsSummary, PageView, VisitorSession } from "@shared/schema";
import type { ReferralData } from "@/types/referrals";

// Define PaymentTransaction interface
interface PaymentTransaction {
  id: string;
  stripeId: string;
  customerEmail?: string;
  amount: number;
  currency: string;
  status: string;
  created: string;
  productType: string;
  assessmentType?: string;
  productName?: string; // Added missing property
  metadata: string | Record<string, any>;
  isRefunded: boolean;
  refundAmount?: number;
  refundReason?: string;
  promoCode?: string;
  customerId?: string; // Added missing property
}

// Define enhanced transaction type with assessment data
interface EnhancedTransaction extends PaymentTransaction {
  assessmentData?: {
    email: string;
    firstName: string;
    lastName: string;
    gender: string;
    marriageStatus: string;
    desireChildren: string;
    ethnicity: string;
    city: string;
    state: string;
    zipCode: string;
  };
}

// Define type for customer recovery data
interface CustomerRecoveryData {
  payment_id: string;
  payment_date: string;
  amount: number;
  currency: string;
  description: string;
  email: string;
  name: string;
  phone: string;
  address?: any;
  metadata: any;
  product_type: string;
}

// Simple admin authentication
const ADMIN_USERNAME = "admin";
const ADMIN_PASSWORD = "100marriage";

// Calculate age from birthday string (YYYY-MM-DD format)
function calculateAge(birthday: string): number {
  if (!birthday) return 0;
  
  try {
    const birthDate = new Date(birthday);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  } catch (e) {
    return 0;
  }
}

// Calculate match compatibility score (higher is better)
function calculateMatchScore(candidate: AssessmentResult): number {
  const scoreWeight = 0.5;
  const ageWeight = 0.3;
  const locationWeight = 0.2;
  
  // Score ranking - higher scores are better for traditional match
  const scoreRank = candidate.scores.overallPercentage;
  
  // Age ranking - optimal age range is 25-35
  const age = calculateAge(candidate.demographics.birthday);
  let ageRank = 0;
  if (age >= 25 && age <= 35) {
    ageRank = 100; // Optimal age range
  } else if (age < 25) {
    ageRank = 100 - ((25 - age) * 5); // 5% penalty per year under 25
  } else {
    ageRank = 100 - ((age - 35) * 3); // 3% penalty per year over 35
  }
  
  // Location ranking - placeholder (would use zipcode proximity in real implementation)
  // For now, just check if location info is complete
  const locationRank = candidate.demographics.city && 
    candidate.demographics.state && 
    candidate.demographics.zipCode ? 100 : 50;
  
  // Calculate weighted score
  return (scoreRank * scoreWeight) + (ageRank * ageWeight) + (locationRank * locationWeight);
}

// Component for customer data recovery from Stripe
function RecoverySection() {
  const [isRecoveryLoading, setIsRecoveryLoading] = useState(false);
  const [recoveryData, setRecoveryData] = useState<CustomerRecoveryData[] | null>(null);
  const { toast } = useToast();

  const handleRecoverData = async () => {
    setIsRecoveryLoading(true);
    
    try {
      const response = await apiRequest("GET", "/api/admin/customer-data-recovery");
      
      if (!response.ok) {
        throw new Error(`Error retrieving customer data: ${response.statusText}`);
      }
      
      const data = await response.json();
      setRecoveryData(data);
      
      toast({
        title: "Data Recovery Complete",
        description: `Retrieved contact information for ${data.length} customers`,
        variant: "default"
      });
    } catch (error) {
      toast({
        title: "Data Recovery Failed",
        description: error instanceof Error ? error.message : String(error),
        variant: "destructive"
      });
    } finally {
      setIsRecoveryLoading(false);
    }
  };
  
  const handleDownloadCSV = () => {
    if (!recoveryData) return;
    
    try {
      // Create CSV data
      const headers = ["Date", "Email", "Name", "Phone", "Amount", "Product Type", "Description"];
      
      const csvRows = [
        headers.join(','),
        ...recoveryData.map(customer => [
          new Date(customer.payment_date).toLocaleDateString(),
          `"${customer.email || ''}"`,
          `"${customer.name || ''}"`,
          `"${customer.phone || ''}"`,
          customer.amount,
          customer.product_type,
          `"${customer.description || ''}"`,
        ].join(','))
      ];
      
      const csvString = csvRows.join('\n');
      const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', `customer-data-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      toast({
        title: "CSV Generated",
        description: "Customer data has been exported to CSV format",
        variant: "default"
      });
    } catch (error) {
      toast({
        title: "CSV Export Failed",
        description: error instanceof Error ? error.message : String(error),
        variant: "destructive"
      });
    }
  };
  
  return (
    <>
      <div className="mb-4">
        <Button 
          onClick={handleRecoverData}
          className="bg-green-600 hover:bg-green-700 text-white"
          disabled={isRecoveryLoading}
        >
          {isRecoveryLoading ? (
            <>
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              Retrieving Data...
            </>
          ) : (
            <>
              <FileDown className="h-4 w-4 mr-2" />
              Recover Customer Data from Stripe
            </>
          )}
        </Button>
      </div>
      
      {isRecoveryLoading ? (
        <div className="flex justify-center items-center py-12">
          <Loader2 className="h-8 w-8 animate-spin text-gray-500" />
          <span className="ml-2 text-gray-500">Retrieving customer data from Stripe...</span>
        </div>
      ) : recoveryData && recoveryData.length > 0 ? (
        <div className="overflow-x-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Date</TableHead>
                <TableHead>Email</TableHead>
                <TableHead>Name</TableHead>
                <TableHead>Phone</TableHead>
                <TableHead>Amount</TableHead>
                <TableHead>Product Type</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {recoveryData.map((customer, index) => (
                <TableRow key={index}>
                  <TableCell>{new Date(customer.payment_date).toLocaleDateString()}</TableCell>
                  <TableCell>{customer.email || 'N/A'}</TableCell>
                  <TableCell>{customer.name || 'N/A'}</TableCell>
                  <TableCell>{customer.phone || 'N/A'}</TableCell>
                  <TableCell>${customer.amount}</TableCell>
                  <TableCell>
                    <Badge variant={
                      customer.product_type === 'marriage_pool' ? 'secondary' :
                      customer.product_type === 'individual' ? 'outline' :
                      customer.product_type === 'couple' ? 'default' : 'destructive'
                    }>
                      {customer.product_type}
                    </Badge>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
          
          <div className="mt-4 flex justify-between items-center">
            <div className="text-sm text-gray-500">
              Total records: {recoveryData.length}
            </div>
            <Button 
              onClick={handleDownloadCSV}
              className="bg-blue-600 hover:bg-blue-700 text-white"
              size="sm"
            >
              Download CSV
            </Button>
          </div>
        </div>
      ) : recoveryData ? (
        <div className="text-center py-12 text-gray-500">
          No customer data found. Try syncing with Stripe first.
        </div>
      ) : (
        <div className="text-center py-12 text-gray-500">
          Click the button above to recover customer data from Stripe.
        </div>
      )}
    </>
  );
}

export default function AdminDashboard() {
  // Check localStorage for authentication status on initial load
  const [isAuthenticated, setIsAuthenticated] = useState(() => {
    const savedAuth = localStorage.getItem('admin_authenticated');
    return savedAuth === 'true';
  });
  
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const [referralSearchTerm, setReferralSearchTerm] = useState("");
  const [filterGender, setFilterGender] = useState<"all" | "male" | "female">("all");
  const [selectedAssessment, setSelectedAssessment] = useState<AssessmentResult | null>(null);
  const [detailModalOpen, setDetailModalOpen] = useState(false);
  const { toast } = useToast();

  // State for assessment date filtering
  const [assessmentDateRange, setAssessmentDateRange] = useState<{
    startDate?: string,
    endDate?: string,
    requirePayment: boolean,
    promoCodeUsed: boolean,
    completedOnly: boolean
  }>({
    startDate: "2023-01-01", // Default to January 1, 2023 to ensure we capture historical data
    endDate: undefined,
    requirePayment: false,
    promoCodeUsed: false,
    completedOnly: true
  });

  // Completely avoid localStorage caching for assessments to ensure we always get fresh data
  const [cachedAssessments, setCachedAssessments] = useState<AssessmentResult[]>([]);
  
  // Clear existing localStorage data to force fresh fetch
  useEffect(() => {
    try {
      localStorage.removeItem('admin_assessments');
      localStorage.removeItem('admin_payments');
    } catch (err) {
      console.error("Error clearing localStorage:", err);
    }
  }, []);
  
  // Query to fetch assessments with date filtering
  const { data: assessments, isLoading, error, refetch: refetchAssessments } = useQuery<AssessmentResult[]>({
    queryKey: ['/api/admin/assessments', assessmentDateRange],
    queryFn: async () => {
      // Only fetch if authenticated
      if (!isAuthenticated) return [];
      
      const params = new URLSearchParams();
      
      if (assessmentDateRange.startDate) {
        params.append('startDate', assessmentDateRange.startDate);
      }
      
      if (assessmentDateRange.endDate) {
        params.append('endDate', assessmentDateRange.endDate);
      }
      
      if (assessmentDateRange.requirePayment) {
        params.append('requirePayment', 'true');
      }
      
      if (assessmentDateRange.promoCodeUsed) {
        params.append('promoCodeUsed', 'true');
      }
      
      // Remove the completedOnly filter to show all assessments
      // if (assessmentDateRange.completedOnly) {
      //   params.append('completedOnly', 'true');
      // }
      
      const queryString = params.toString();
      const url = queryString ? `/api/admin/assessments?${queryString}` : '/api/admin/assessments';
      
      const response = await apiRequest("GET", url);
      
      if (!response.ok) {
        throw new Error("Failed to fetch assessments");
      }
      
      const data = await response.json();
      
      // Save to localStorage when new data arrives
      try {
        localStorage.setItem('admin_assessments', JSON.stringify(data));
        setCachedAssessments(data);
      } catch (err) {
        console.error("Error caching assessments:", err);
      }
      
      return data;
    },
    enabled: isAuthenticated,
    initialData: cachedAssessments.length > 0 ? cachedAssessments : undefined,
  });
  
  // Initialize referrals from localStorage if available
  const [cachedReferrals, setCachedReferrals] = useState<ReferralData[]>(() => {
    try {
      const saved = localStorage.getItem('admin_referrals');
      return saved ? JSON.parse(saved) : [];
    } catch (err) {
      console.error("Error loading cached referrals:", err);
      return [];
    }
  });
  
  // Query to fetch referrals
  const { data: referrals, isLoading: isLoadingReferrals, error: referralsError } = useQuery<ReferralData[]>({
    queryKey: ['/api/admin/referrals'],
    queryFn: async () => {
      // Only fetch if authenticated
      if (!isAuthenticated) return [];
      
      const response = await apiRequest("GET", "/api/admin/referrals");
      
      if (!response.ok) {
        throw new Error("Failed to fetch referrals");
      }
      
      const data = await response.json();
      
      // Save to localStorage when new data arrives
      try {
        localStorage.setItem('admin_referrals', JSON.stringify(data));
        setCachedReferrals(data);
      } catch (err) {
        console.error("Error caching referrals:", err);
      }
      
      return data;
    },
    enabled: isAuthenticated,
    initialData: cachedReferrals.length > 0 ? cachedReferrals : undefined,
  });
  
  // Website Analytics - summary data
  const [analyticsPeriod, setAnalyticsPeriod] = useState<'day' | 'week' | 'month' | 'year'>('week');
  
  // Initialize analytics summary from localStorage if available
  const [cachedAnalyticsSummary, setCachedAnalyticsSummary] = useState<AnalyticsSummary>(() => {
    try {
      const saved = localStorage.getItem('admin_analytics_summary');
      return saved ? JSON.parse(saved) : {
        totalVisitors: 0,
        totalPageViews: 0,
        topPages: [],
        dailyVisitors: [],
        conversionRate: 0,
        averageSessionDuration: 0
      };
    } catch (err) {
      console.error("Error loading cached analytics summary:", err);
      return {
        totalVisitors: 0,
        totalPageViews: 0,
        topPages: [],
        dailyVisitors: [],
        conversionRate: 0,
        averageSessionDuration: 0
      };
    }
  });
  
  const { data: analyticsSummary, isLoading: isLoadingAnalytics } = useQuery<AnalyticsSummary>({
    queryKey: ['/api/admin/analytics/summary', analyticsPeriod],
    queryFn: async () => {
      if (!isAuthenticated) return cachedAnalyticsSummary;
      
      const response = await apiRequest("GET", `/api/admin/analytics/summary?period=${analyticsPeriod}`);
      
      if (!response.ok) {
        throw new Error("Failed to fetch analytics summary");
      }
      
      const data = await response.json();
      
      // Save to localStorage when new data arrives
      try {
        localStorage.setItem('admin_analytics_summary', JSON.stringify(data));
        setCachedAnalyticsSummary(data);
      } catch (err) {
        console.error("Error caching analytics summary:", err);
      }
      
      return data;
    },
    enabled: isAuthenticated,
    initialData: cachedAnalyticsSummary,
  });
  
  // Initialize page views from localStorage if available
  const [cachedPageViews, setCachedPageViews] = useState<PageView[]>(() => {
    try {
      const saved = localStorage.getItem('admin_page_views');
      return saved ? JSON.parse(saved) : [];
    } catch (err) {
      console.error("Error loading cached page views:", err);
      return [];
    }
  });
  
  // Website Analytics - page views data
  const { data: pageViews, isLoading: isLoadingPageViews } = useQuery<PageView[]>({
    queryKey: ['/api/admin/analytics/page-views'],
    queryFn: async () => {
      if (!isAuthenticated) return [];
      
      const response = await apiRequest("GET", "/api/admin/analytics/page-views");
      
      if (!response.ok) {
        throw new Error("Failed to fetch page views");
      }
      
      const data = await response.json();
      
      // Save to localStorage when new data arrives
      try {
        localStorage.setItem('admin_page_views', JSON.stringify(data));
        setCachedPageViews(data);
      } catch (err) {
        console.error("Error caching page views:", err);
      }
      
      return data;
    },
    enabled: isAuthenticated,
    initialData: cachedPageViews.length > 0 ? cachedPageViews : undefined,
  });
  
  // Initialize visitor sessions from localStorage if available
  const [cachedVisitorSessions, setCachedVisitorSessions] = useState<VisitorSession[]>(() => {
    try {
      const saved = localStorage.getItem('admin_visitor_sessions');
      return saved ? JSON.parse(saved) : [];
    } catch (err) {
      console.error("Error loading cached visitor sessions:", err);
      return [];
    }
  });
  
  // Website Analytics - visitor sessions data
  const { data: visitorSessions, isLoading: isLoadingVisitorSessions } = useQuery<VisitorSession[]>({
    queryKey: ['/api/admin/analytics/visitor-sessions'],
    queryFn: async () => {
      if (!isAuthenticated) return [];
      
      const response = await apiRequest("GET", "/api/admin/analytics/visitor-sessions");
      
      if (!response.ok) {
        throw new Error("Failed to fetch visitor sessions");
      }
      
      const data = await response.json();
      
      // Save to localStorage when new data arrives
      try {
        localStorage.setItem('admin_visitor_sessions', JSON.stringify(data));
        setCachedVisitorSessions(data);
      } catch (err) {
        console.error("Error caching visitor sessions:", err);
      }
      
      return data;
    },
    enabled: isAuthenticated,
    initialData: cachedVisitorSessions.length > 0 ? cachedVisitorSessions : undefined,
  });
  
  // Payment transactions data
  const [transactionDateRange, setTransactionDateRange] = useState<{start?: string, end?: string}>({});
  const [emailSearchTerm, setEmailSearchTerm] = useState<string>("");
  const [searchResults, setSearchResults] = useState<AssessmentResult[] | null>(null);
  
  // Remove customerRecoveryData state as it's now in the RecoverySection component
  
  // State for assessment reminder system
  const [sendingReminders, setSendingReminders] = useState<boolean>(false);
  const [reminderDaysAgo, setReminderDaysAgo] = useState<number>(3);
  
  // Mutation to send assessment reminders
  const { mutate: sendAssessmentReminders, isPending: isSendingReminders } = useMutation({
    mutationFn: async () => {
      setSendingReminders(true);
      
      // Show toast that reminders are being sent
      toast({
        title: "Sending Reminders",
        description: "Processing incomplete assessments and sending reminders...",
        variant: "default"
      });
      
      const response = await apiRequest("POST", "/api/admin/send-assessment-reminders", {
        daysAgo: reminderDaysAgo
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to send assessment reminders: ${errorText}`);
      }
      
      return response.json();
    },
